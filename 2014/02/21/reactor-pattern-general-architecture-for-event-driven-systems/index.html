<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Phaninder,hello@phaninder.com"><title>Reactor pattern: general architecture for event-driven systems · Phani</title><meta name="description" content="Every app is built to scale at one time or another.
With traditional technique of spawning a thread-per-response or crating socket-per-incoming connec"><meta name="keywords" content="Scaling Infrastructure, Docker, NodeJs, Postgres, ReactJs, Phonegap, Web application security, es7"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/ds-embed.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Phani</a></h3><div class="description"><p>My findings and ramblings</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/PhaniPasupula" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="https://uk.linkedin.com/in/phaninder-pasupula-aab4a02b" target="_blank"><i class="fa fa-linkedin"></i></a></li></ul><div class="footer"><div class="by_farbox"><a href="" target="_blank">Copyright 2014-2017</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/da8ad3d7a783fda9082894427e6be2a9?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Reactor pattern: general architecture for event-driven systems</a></h3></div><div class="post-content"><p><em>Every app is built to scale at one time or another.</em></p>
<p>With traditional technique of spawning a thread-per-response or crating socket-per-incoming connection or with thread pool pattern makes it difficult to scale (please note that this is not a statement as the factor of scalability largely depends on the type of problem your app is solving).</p>
<p>Problem with having many threads is it may lead performance problems due to overhead of context switching and complex concurrency schemes. <strong>Most of the time spent</strong> by server doing context-switching between requests where threads handling <strong>event listeners do not read or write data frequently.</strong></p>
<p><em>To reduce the overhead of context switching the concept of non blocking IO is put to practice.</em></p>
<h4 id="Reactor-pattern"><a href="#Reactor-pattern" class="headerlink" title="Reactor pattern:"></a><strong>Reactor pattern:</strong></h4><p>Reactor pattern is asynchronous or non blocking model that Node uses for I/O. This is one of the <a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="external">earliest papers</a> where reactor pattern is discussed in detail.</p>
<p>Imagine writing a web service. Typically web server tasks include -</p>
<ul>
<li>Read request</li>
<li>Decode request</li>
<li>Process service</li>
<li>Encode reply</li>
<li>Send reply</li>
</ul>
<p>Each task differ in nature and cost. Mostly tasks <strong>involves IO</strong>, whether it is writing or reading from a database or a disk/filesystem or a computational service; they all tend to be <strong>blocking operations</strong>. This means that the <strong>processor</strong> can spend most of its time <strong>idle</strong> waiting for I/O operations to complete. What if we can delegate an operation to an handler and continue with other tasks but get back to them when finished. Event-driven IO uses similar ideas using reactor pattern technique but many systems differ in design.</p>
<p>There are two important actors in the architecture of reactor pattern:</p>
<p><img src="http://2.bp.blogspot.com/-gZ2vKl9VpWI/Uwan3po6olI/AAAAAAAAB_0/FDpfgQdUt3w/s1600/reactor_pattern+(2" alt="Reactor Pattern">.png)</p>
<p>Fig 1.0 : Basic skeleton of a Reactor pattern</p>
<p>The reason I call the components as Actors is due to the fact that they don’t have a shared state, communication is done by message passing/notifications. (depends on the implementation though)</p>
<p><strong>Handler</strong> : Performs non-blocking actions</p>
<p><strong>Reactor</strong> : This responds to IO events by dispatching the appropriate handler.</p>
<p>Basic <em>dispatch()</em> in the reactor implementation would be a single threaded event loop dispatches events on handles (e.g. sockets, file descriptors) to event handlers.</p>
<blockquote>
<pre style="padding-left: 30px;">_select (handlers);  
__foreach h in handlers loop  
_ _h.handle_event(type)__end loop_</pre>

</blockquote>
<p>So when a request arrives on the server, they are serviced one at a time and dispatched to its handler as fast as they can. When the code does some IO, it receives the async treatment of “getting back” to it when it finishes. Until then, it services another request. This avoids the “hostaged” memory and processing, and keeps your CPU utilization maximum all the time.</p>
<h4 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits:"></a><strong>Benefits:</strong></h4><ul>
<li><strong>Separation of concerns</strong> - Components are modular, event handlers are separated from low-level mechanism and handlers can be composed easily as they are decoupled of application-independent mechanisms from application-specific policies. In other words, handler objects need not be aware of how events are dispatched.</li>
<li>No thread context switching</li>
<li><strong>Concurrency is simplified</strong> due to being in a single thread. So you never have the risk of mutable thread accessing the same mutable state.</li>
</ul>
<h4 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks:"></a><strong>Drawbacks</strong>:</h4><ul>
<li><strong>Non-pre-emptive model</strong> - Handlers cannot take long time.</li>
<li><strong>Difficult to understand</strong> to get started with but latter comes <strong>hard to debug</strong>. Since it is not always clear why a particular handler was invoked, and because it may be difficult to repeat the computation preceding the fault.</li>
<li>One faulty event handler your entire server is down.</li>
</ul>
<p><em>This pattern is the foundation for the events processing structure implemented in Node.js, Ruby’s eventmachine, JBoss Netty, Apache MINA, Python’s Twisted event-driven I/O libraries.</em></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2014-02-21</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://blog.phaninder.com/2014/02/21/reactor-pattern-general-architecture-for-event-driven-systems/,Phani,Reactor pattern: general architecture for event-driven systems,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2014/03/10/mongodbmongoose-connect-best-practices/" title="MongoDB/Mongoose connect best practices" class="btn">prev_post</a></li><li class="next pagbuttons"><a role="navigation" href="/2014/02/17/adventures-at-nodecoptor/" title="Adventures at NodeCoptor" class="btn">next_post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>